// this list automatically generated by lexer2

// form:
//   <code> : <name> [<alias>] ;

    0 : L2_EOF               ;
    1 : L2_NAME              ;
    2 : L2_TYPE_NAME         ;
    3 : L2_VARIABLE_NAME     ;
    4 : L2_INT_LITERAL       ;
    5 : L2_FLOAT_LITERAL     ;
    6 : L2_STRING_LITERAL    ;
    7 : L2_CHAR_LITERAL      ;
    8 : L2_UDEF_QUAL         ;
    9 : L2_ASM               "asm" ;
   10 : L2_AUTO              "auto" ;
   11 : L2_BREAK             "break" ;
   12 : L2_BOOL              "bool" ;
   13 : L2_CASE              "case" ;
   14 : L2_CATCH             "catch" ;
   15 : L2_CDECL             "cdecl" ;
   16 : L2_CHAR              "char" ;
   17 : L2_CLASS             "class" ;
   18 : L2_CONST             "const" ;
   19 : L2_CONST_CAST        "const_cast" ;
   20 : L2_CONTINUE          "continue" ;
   21 : L2_DEFAULT           "default" ;
   22 : L2_DELETE            "delete" ;
   23 : L2_DO                "do" ;
   24 : L2_DOUBLE            "double" ;
   25 : L2_DYNAMIC_CAST      "dynamic_cast" ;
   26 : L2_ELSE              "else" ;
   27 : L2_ENUM              "enum" ;
   28 : L2_EXPLICIT          "explicit" ;
   29 : L2_EXPORT            "export" ;
   30 : L2_EXTERN            "extern" ;
   31 : L2_FALSE             "false" ;
   32 : L2_FLOAT             "float" ;
   33 : L2_FOR               "for" ;
   34 : L2_FRIEND            "friend" ;
   35 : L2_GOTO              "goto" ;
   36 : L2_IF                "if" ;
   37 : L2_INLINE            "inline" ;
   38 : L2_INT               "int" ;
   39 : L2_LONG              "long" ;
   40 : L2_MUTABLE           "mutable" ;
   41 : L2_NAMESPACE         "namespace" ;
   42 : L2_NEW               "new" ;
   43 : L2_OPERATOR          "operator" ;
   44 : L2_PASCAL            "pascal" ;
   45 : L2_PRIVATE           "private" ;
   46 : L2_PROTECTED         "protected" ;
   47 : L2_PUBLIC            "public" ;
   48 : L2_REGISTER          "register" ;
   49 : L2_REINTERPRET_CAST  "reinterpret_cast" ;
   50 : L2_RETURN            "return" ;
   51 : L2_SHORT             "short" ;
   52 : L2_SIGNED            "signed" ;
   53 : L2_SIZEOF            "sizeof" ;
   54 : L2_STATIC            "static" ;
   55 : L2_STATIC_CAST       "static_cast" ;
   56 : L2_STRUCT            "struct" ;
   57 : L2_SWITCH            "switch" ;
   58 : L2_TEMPLATE          "template" ;
   59 : L2_THIS              "this" ;
   60 : L2_THROW             "throw" ;
   61 : L2_TRUE              "true" ;
   62 : L2_TRY               "try" ;
   63 : L2_TYPEDEF           "typedef" ;
   64 : L2_TYPEID            "typeid" ;
   65 : L2_TYPENAME          "typename" ;
   66 : L2_UNION             "union" ;
   67 : L2_UNSIGNED          "unsigned" ;
   68 : L2_USING             "using" ;
   69 : L2_VIRTUAL           "virtual" ;
   70 : L2_VOID              "void" ;
   71 : L2_VOLATILE          "volatile" ;
   72 : L2_WCHAR_T           "wchar_t" ;
   73 : L2_WHILE             "while" ;
   74 : L2_LPAREN            "(" ;
   75 : L2_RPAREN            ")" ;
   76 : L2_LBRACKET          "[" ;
   77 : L2_RBRACKET          "]" ;
   78 : L2_ARROW             "->" ;
   79 : L2_COLONCOLON        "::" ;
   80 : L2_DOT               "." ;
   81 : L2_BANG              "!" ;
   82 : L2_TILDE             "~" ;
   83 : L2_PLUS              "+" ;
   84 : L2_MINUS             "-" ;
   85 : L2_PLUSPLUS          "++" ;
   86 : L2_MINUSMINUS        "--" ;
   87 : L2_AND               "&" ;
   88 : L2_STAR              "*" ;
   89 : L2_DOTSTAR           ".*" ;
   90 : L2_ARROWSTAR         "->*" ;
   91 : L2_SLASH             "/" ;
   92 : L2_PERCENT           "%" ;
   93 : L2_LEFTSHIFT         "<<" ;
   94 : L2_RIGHTSHIFT        ">>" ;
   95 : L2_LESSTHAN          "<" ;
   96 : L2_LESSEQ            "<=" ;
   97 : L2_GREATERTHAN       ">" ;
   98 : L2_GREATEREQ         ">=" ;
   99 : L2_EQUALEQUAL        "==" ;
  100 : L2_NOTEQUAL          "!=" ;
  101 : L2_XOR               "^" ;
  102 : L2_OR                "|" ;
  103 : L2_ANDAND            "&&" ;
  104 : L2_OROR              "||" ;
  105 : L2_QUESTION          "?" ;
  106 : L2_COLON             ":" ;
  107 : L2_EQUAL             "=" ;
  108 : L2_STAREQUAL         "*=" ;
  109 : L2_SLASHEQUAL        "/=" ;
  110 : L2_PERCENTEQUAL      "%=" ;
  111 : L2_PLUSEQUAL         "+=" ;
  112 : L2_MINUSEQUAL        "-=" ;
  113 : L2_ANDEQUAL          "&=" ;
  114 : L2_XOREQUAL          "^=" ;
  115 : L2_OREQUAL           "|=" ;
  116 : L2_LEFTSHIFTEQUAL    "<<=" ;
  117 : L2_RIGHTSHIFTEQUAL   ">>=" ;
  118 : L2_COMMA             "," ;
  119 : L2_ELLIPSIS          "..." ;
  120 : L2_SEMICOLON         ";" ;
  121 : L2_LBRACE            "{" ;
  122 : L2_RBRACE            "}" ;
  123 : L2___ATTRIBUTE__     "__attribute__" ;
  124 : L2___FUNCTION__      "__FUNCTION__" ;
  125 : L2___LABEL__         "__label__" ;
  126 : L2___PRETTY_FUNCTION__ "__PRETTY_FUNCTION__" ;
  127 : L2___TYPEOF__        "__typeof__" ;
  128 : L2_OWNER             "owner_ptr_qualifier" ;
  129 : L2_PREFER_REDUCE     "PREFER_REDUCE" ;
  130 : L2_PREFER_SHIFT      "PREFER_SHIFT" ;
  131 : L2_THMPRV_ASSERT     "thmprv_assert" ;
  132 : L2_THMPRV_ASSUME     "thmprv_assume" ;
  133 : L2_THMPRV_INVARIANT  "thmprv_invariant" ;
  134 : L2_IMPLIES           "==>" ;
  135 : L2_THMPRV_PRE        "thmprv_pre" ;
  136 : L2_THMPRV_POST       "thmprv_post" ;
  137 : L2_THMPRV_LET        "thmprv_let" ;
  138 : L2_THMPRV_ATTR       "thmprv_attr" ;
  139 : L2_THMPRV_FORALL     "thmprv_forall" ;
  140 : L2_THMPRV_EXISTS     "thmprv_exists" ;
  141 : L2_THMPRV_PURE_ASSERT "thmprv_pure_assert" ;
  142 : L2_THMPRV_BIND       "thmprv_bind" ;
  143 : L2_THMPRV_DECL       "thmprv_decl" ;
  144 : L2_THMPRV_PREDICATE  "thmprv_predicate" ;
